# KyroDB — Durable KV store with a Production Recursive Model Index (RMI)

**Status:** Alpha (focused scope: KV + RMI)

**One-liner:** KyroDB is a durable, append-only key-value engine with a production-grade learned index (RMI) for ultra-fast point lookups and predictable tail latency.

---
See visiondocument.md for long term vision for the Database
## At a glance

- RMI vs B-Tree point lookup microbench (median):

![RMI vs B-Tree (1M–300M keys)](bench/rmi_vs_btree.png)

Data: `bench/rmi_vs_btree_data.csv` (generated by `comp.py`). Reproduce steps below.

---

## TL;DR — Try it now

```bash
# 1) Run the engine (enable RMI features)
cargo run -p engine --features learned-index -- serve 127.0.0.1 3030

# 2) Health and offset
curl -s http://127.0.0.1:3030/health
curl -s http://127.0.0.1:3030/v1/offset

# 3) Put/Get (HTTP)
curl -sX POST http://127.0.0.1:3030/v1/put \
  -H 'content-type: application/json' \
  -d '{"key":123,"value":"hello"}'

curl -s "http://127.0.0.1:3030/v1/lookup?key=123"

# 4) Optional: build the learned index (RMI)
curl -sX POST http://127.0.0.1:3030/v1/rmi/build

# 5) Fast data-plane endpoints (for benchmarks)
curl -i "http://127.0.0.1:3030/v1/lookup_fast/123"      # 200 (offset bytes) or 404
curl -i "http://127.0.0.1:3030/v1/get_fast/123"         # 200 (value) or 404
curl -i "http://127.0.0.1:3030/v1/lookup_raw?key=123"   # 204 if exists, 404 if not
```

Notes
- API is versioned under `/v1/*`. Metrics stay at `/metrics` for Prometheus scraping.
- To require auth: start with `--auth-token <TOKEN>` and send `Authorization: Bearer <TOKEN>`.
- Release build: `cargo build -p engine --release` (binary at `target/release/kyrodb-engine`).
- Basic CLI (optional): `cd orchestrator && go build -o kyrodbctl .`

---

## HTTP status semantics (fast routes)

- `POST /v1/put` → 200 with `{ "offset": <u64> }` on success; 500 with `{ "error": ... }` on failure.
- `GET /v1/lookup_fast/{key}` → 200 with `application/octet-stream` body (8-byte offset) on hit; 404 on miss.
- `GET /v1/get_fast/{key}` → 200 with value bytes on hit; 404 on miss.
- `GET /v1/lookup_raw?key=...` → 204 No Content on hit; 404 on miss (offset not returned).
- `POST /v1/rmi/build` → 200 with `{ ok: bool, count: <usize> }`.
- `POST /v1/warmup` → 200 with `{ status: "ok" }`.

`GET /v1/lookup?key=...` returns 200 with a JSON object on hit, or 200 with `{ "error": "not found" }` on miss.

---

## Performance methodology and caveats

- Warm vs cold: first queries after start pay OS page-fault costs. For steady-state latency, either:
  - set `KYRODB_WARM_ON_START=1` before starting the server, or
  - call `POST /v1/rmi/build` (if needed) then `POST /v1/warmup` prior to measurements, or
  - let the workload run a brief priming phase before measuring.
- Distributions: RMI shines for typical key distributions. Our bench supports `--dist uniform|zipf` (`--zipf-theta` in code as `--zipf_theta`). Run both.
- Concurrency & values: Latency includes network + value read cost on `/v1/get_fast/{k}`. Use `/v1/lookup_fast/{k}` to measure index-only.
- OS differences: Linux honors MADV_WILLNEED/HUGEPAGE; macOS may show higher first-hit tails.
- CPU features: SIMD paths are runtime-detected (AVX2/AVX-512 on x86_64; NEON on aarch64); `--release` recommended.

---

## Reproducible Benchmarks

See `bench/README.bench.md` for the full workflow. Highlights:

- Build release binaries with features used in papers/blogs:
  - `learned-index` enables the RMI read path and `/v1/rmi/build`.
  - `bench-no-metrics` disables Prometheus counters in hot paths for purer numbers.
- Freeze index during the read phase: build once (`/v1/rmi/build`), then avoid rebuilds.
- Capture artifacts to `bench/results/<commit>/` via `bench/scripts/capture.sh`.
- Adjust RMI via env vars: `KYRODB_RMI_TARGET_LEAF`, `KYRODB_RMI_EPS_MULT`.

Common commands:

```bash
# Microbench (in-process): compare RMI vs B-Tree
KYRO_BENCH_N=10000000 cargo bench -p bench --bench kv_index   # try 1e6, 1e7, 5e7, 3e8

# HTTP workload bench (read-mostly)
# 1) Start the engine (suggest: release, learned-index)
cargo run -p engine --features learned-index --release -- serve 127.0.0.1 3030

# 2) Load + read with the bench client, export CSV
# Example: 10M keys, 16-byte values, 64 concurrent readers, 30s read phase
COMMIT=$(git rev-parse --short HEAD)
cargo run -p bench --release -- \
  --base http://127.0.0.1:3030 \
  --load-n 10000000 \
  --val-bytes 16 \
  --load-concurrency 64 \
  --read-concurrency 64 \
  --read-seconds 30 \
  --dist uniform \
  --out-csv bench/results/${COMMIT}/http_uniform_10m.csv

# 3) Generate plot + CSV for paper-style figures
python3 -m venv .venv && source .venv/bin/activate && pip install -r requirements.txt || pip install numpy matplotlib
python comp.py  # writes bench/http_uniform_64c_30s.png and SVG
```

Tips for fair numbers
- Label warm vs cold in results; include both when comparing against B-Tree/LSM.
- Pin CPU, keep system idle, disable turbo scaling if possible.
- Use `--features bench-no-metrics` when comparing tight hot-paths.
- Prefer the `/v1/lookup_fast` and `/v1/get_fast` routes in read tests.

---

## Why KyroDB (what we’re solving)

Many systems combine a log + key-value store + index and accept complexity, large memory overhead, or brittle tail latencies. KyroDB’s thesis:

> You can get a smaller, simpler, and faster single-binary KV engine by pairing an immutable WAL + snapshot durability model with a learned primary index (RMI) tuned for real workload distributions.

This repository is intentionally narrow: the primary goal is producing a production-grade KV engine (durability, compaction, recovery) + RMI implementation and reproducible benchmarks that demonstrate the advantages of learned indexes in real workloads.

---

## Primary use cases

- High-RPS point lookups where p99 predictability matters (feature stores, metadata services).
- Embedded single-binary KV for edge or microservices with on-disk persistence.
- Read-mostly workloads with occasional upserts, benefiting from compact on-disk layouts.
- Research/teaching reference for practical learned indexes with a real KV engine.

---

## Scope (what this repo contains now)

**IN SCOPE**

- Durable append-only Write-Ahead Log (WAL) with configurable fsync policy.
- Snapshotter with atomic swap for fast crash recovery.
- In-memory recent-write delta and a single-node read path.
- RMI builder + on-disk loader + read path (feature-gated) — default read path when built.
- WAL size management via snapshots and truncation hooks.
- HTTP data plane for Put/Get and HTTP control plane (health, metrics, admin).
- `kyrodbctl` client for basic admin and dev workflows.

**OUT OF SCOPE (for now)**

- Vector search, ANN (HNSW), and vector-related APIs.
- Full SQL engine, complex query planner, joins, or multi-model features.
- Distributed clustering, replication, sharding.
- Production packaging beyond a single binary + Dockerfile (to be added once core is stable).

---

## Quickstart (developer)

Prereqs: Rust toolchain, (optional) Go for `kyrodbctl`.

Build and run engine (HTTP)

```bash
# from repo root
cargo run -p engine -- serve 127.0.0.1 3030
```

Build CLI (optional)

```bash
cd orchestrator
# build CLI binary in this folder
go build -o kyrodbctl .
```

Basic admin + KV demo (HTTP)

```bash
# health and offset
curl -s http://127.0.0.1:3030/health
curl -s http://127.0.0.1:3030/v1/offset

# trigger a snapshot
curl -sX POST http://127.0.0.1:3030/v1/snapshot

# KV put via HTTP
curl -sX POST http://127.0.0.1:3030/v1/put \
  -H 'content-type: application/json' \
  -d '{"key":123,"value":"hello"}'

# Fast lookups
curl -i "http://127.0.0.1:3030/v1/lookup_raw?key=123"   # 204/404
curl -i "http://127.0.0.1:3030/v1/lookup_fast/123"      # 200/404
curl -i "http://127.0.0.1:3030/v1/get_fast/123"         # 200/404
```

Notes:
- If you start the server with `--auth-token <TOKEN>`, pass `Authorization: Bearer <TOKEN>` headers in your HTTP requests; the CLI will add a flag for this soon.
- Release build: `cargo build -p engine --release` (binary at `target/release/engine`).
- Structured logs: set `RUST_LOG=info` (JSON structured logs supported via tracing).

---

## Protocol decision (current)

- Data plane: versioned HTTP/JSON under `/v1/*` for Put/Get and admin.
- Control plane: Prometheus metrics at `/metrics` (unversioned for scraping).

gRPC for the data plane is planned (see Roadmap) but not implemented yet.

---

## Architecture (high level)

- **PersistentEventLog (WAL)** — append-only records with configurable fsync.
- **Snapshotter** — write new snapshot → atomic rename/swap → truncate WAL.
- **In-memory delta** — fast recent writes map checked before probing index.
- **RMI (learned index)** — builder + on-disk format implemented; read path predicts position and performs a bounded last‑mile probe (feature‑gated).
- **Compactor** — builds new snapshots with latest values and reclaims WAL space.

Simplified flow (current):

- Client -> HTTP -> WAL.append -> mem-delta -> background snapshot
-                  \-> Get -> mem-delta -> RMI predict -> bounded probe -> disk

---

## What’s implemented (current status)

- WAL append + recovery ✅
- Snapshot + atomic swap ✅
- Cold start recovery (snapshot load + WAL replay) ✅
- In-memory delta and baseline read path ✅
- RMI build + on-disk loader + read path ✅ (feature: `learned-index`)
- Compaction (keep-latest) ✅ (periodic + size-based triggers)
- Basic HTTP API + `kyrodbctl` for admin ✅
- Read counters: `kyrodb_rmi_reads_total` vs `kyrodb_btree_reads_total` ✅

---


## Ops Guide (quick notes)

- Backups: copy `snapshot.bin`, `snapshot.data`, and `manifest.json` atomically; verify checksums on RMI (`index-rmi.bin`).
- Restore: place files in data dir and start; WAL will be empty post-snapshot; manifest is the commit point.
- Compaction: configure via `--compact-interval-secs` and `--compact-when-wal-bytes` or size-based `--wal-max-bytes`.
- Sizing: set `--wal-segment-bytes` and `--wal-max-segments` for rotation + retention.
- Metrics: scrape `/metrics`; key series include `kyrodb_appends_total`, `kyrodb_rmi_reads_total`, `kyrodb_btree_reads_total`.

---

## Roadmap (focus: KV + RMI)

**Short-term (now)**

- Harden WAL + snapshot atomicity and crash tests (fuzz/CI).
- Finalize RMI file layout (mmap-friendly) + versioning.
- Implement compaction + WAL truncation service.
- Publish reproducible benches for 10M and 50M keys.

**Mid-term**

- gRPC data-plane for Put/Get/Subscribe.
- Perf polish (prefetch, packed layouts), reduce probe tail latencies, autoswitch rebuild heuristics.
- Deliver Docker image + reproducible bench workflow.

**Long-term (after core is stable)**

- Consider range queries, optional supplemental B-Tree fallback, replication model, and selective vector features (as an experimental plugin).

---

## How to help / contribute

- Open issues with proposed changes and include tests (unit, property) when possible.
- When touching WAL/snapshot/RMI code paths, include regression/bench evidence.
- Share bench CSVs in `/bench/results/<your-name>` with machine specs for comparison.

---

## License

Apache-2.0

---

## Contact / Community

Open an issue for design discussions; label PRs that are experimental with `experimental`. For fast feedback ping @vatskishan03 on GitHub and Twitter(kishanvats03).

## TLS and reverse proxy

Run kyrodb-engine behind a TLS reverse proxy. Example: Caddy (automatic HTTPS):

```
# Caddyfile
kyro.example.com {
  reverse_proxy 127.0.0.1:8080
  header {
    Strict-Transport-Security "max-age=31536000; includeSubDomains; preload"
  }
}
```

Nginx (Let's Encrypt via certbot):

```
server {
  listen 443 ssl http2;
  server_name kyro.example.com;
  ssl_certificate /etc/letsencrypt/live/kyro.example.com/fullchain.pem;
  ssl_certificate_key /etc/letsencrypt/live/kyro.example.com/privkey.pem;

  location / {
    proxy_pass http://127.0.0.1:8080;
    proxy_set_header Host $host;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto https;
  }
}
```

Recommended: bind KyroDB on localhost and expose only via proxy.

## Rate limiting

KyroDB includes simple per-IP token-bucket rate limiting:
- Admin routes (snapshot, compact, warmup, rmi build, replay): default 2 rps burst 5
- Data routes (put, lookup, get_fast, sql, vector): default 5000 rps burst 10000

Tune via environment variables:
- KYRODB_RL_ADMIN_RPS, KYRODB_RL_ADMIN_BURST
- KYRODB_RL_DATA_RPS, KYRODB_RL_DATA_BURST

429 Too Many Requests is returned when limited. Health and metrics are not limited.
